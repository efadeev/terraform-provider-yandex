// Code generated by tfgen. DO NOT EDIT.

package yandex_lockbox_secret_iam_member

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/yandex-cloud/go-genproto/yandex/cloud/access"
	lockboxv1sdk "github.com/yandex-cloud/go-sdk/services/lockbox/v1"
	globallock "github.com/yandex-cloud/terraform-provider-yandex/common/mutexkv"
	accessbinding "github.com/yandex-cloud/terraform-provider-yandex/pkg/iam_access"
	provider_config "github.com/yandex-cloud/terraform-provider-yandex/yandex-framework/provider/config"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
)

const (
	defaultPageSize = 1000
	defaultTimeout  = 5 * time.Minute
)

type iamPolicyModifyFunc func(p *accessbinding.Policy) error

var mutexKV = globallock.NewMutexKV()

type IAMMemberUpdater struct {
	secretId       string
	providerConfig *provider_config.Config
}

func NewResource() resource.Resource {
	return &IAMMemberUpdater{}
}

func (u *IAMMemberUpdater) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Allows creation and management of a single binding within IAM policy for an existing `secret`.",
		Attributes: map[string]schema.Attribute{
			"role": schema.StringAttribute{
				MarkdownDescription: "The role that should be assigned. Only one yandex_lockbox_secret_iam_member can be used per role.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"member": schema.StringAttribute{
				MarkdownDescription: "An array of identities that will be granted the privilege in the `role`. Each entry can have one of the following values:\n * **userAccount:{user_id}**: A unique user ID that represents a specific Yandex account.\n * **serviceAccount:{service_account_id}**: A unique service account ID.\n * **federatedUser:{federated_user_id}**: A unique federated user ID.\n * **federatedUser:{federated_user_id}:**: A unique SAML federation user account ID.\n * **group:{group_id}**: A unique group ID.\n * **system:group:federation:{federation_id}:users**: All users in federation.\n * **system:group:organization:{organization_id}:users**: All users in organization.\n * **system:allAuthenticatedUsers**: All authenticated users.\n * **system:allUsers**: All users, including unauthenticated ones.\n\n~> for more information about system groups, see [Cloud Documentation](https://yandex.cloud/docs/iam/concepts/access-control/system-group).\n\n",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"secret_id": schema.StringAttribute{
				MarkdownDescription: "The ID of the compute `secret` to attach the policy to.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"sleep_after": schema.Int64Attribute{
				MarkdownDescription: "For test purposes, to compensate IAM operations delay",
				Optional:            true,
			},
		},
	}
}

func (u *IAMMemberUpdater) Initialize(ctx context.Context, state accessbinding.Extractable, diag *diag.Diagnostics) {
	var id types.String

	diag.Append(state.GetAttribute(ctx, path.Root("secret_id"), &id)...)
	u.secretId = id.ValueString()
}

func (u *IAMMemberUpdater) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerConfig, ok := req.ProviderData.(*provider_config.Config)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *provider_config.Config, got: %T. "+
				"Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	u.providerConfig = providerConfig
}

func (r *IAMMemberUpdater) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = "yandex_lockbox_secret_iam_member"
}

func (r *IAMMemberUpdater) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	idParts := strings.Split(req.ID, ",")

	if len(idParts) != 3 {
		resp.Diagnostics.AddError(
			"Invalid import ID",
			"Expected import ID in format 'secret_id role member'",
		)
		return
	}

	member := idParts[2]
	memberParts := strings.SplitN(member, ":", 2)
	if len(memberParts) == 1 || memberParts[0] == "" || memberParts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid member format",
			fmt.Sprintf("Expected 'member' value in TYPE:ID format, got '%s'", member),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("secret_id"), idParts[0])...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("role"), idParts[1])...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("member"), idParts[2])...)
}

func (u *IAMMemberUpdater) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()

	u.Initialize(ctx, req.Plan, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	member := accessbinding.GetResourceIamMemberFromState(ctx, req.Plan, &resp.Diagnostics)

	policyDelta := &accessbinding.PolicyDelta{
		Deltas: []*access.AccessBindingDelta{
			{
				Action:        access.AccessBindingAction_ADD,
				AccessBinding: member,
			},
		},
	}

	mutexKV.Lock(fmt.Sprintf("yandex_lockbox_secret_iam_member-%s", u.secretId))
	defer mutexKV.Unlock(fmt.Sprintf("yandex_lockbox_secret_iam_member-%s", u.secretId))

	tflog.Debug(ctx, fmt.Sprintf("Retrieving access member for yandex_lockbox_secret_iam_member '%s'", u.secretId))

	p, err := u.GetResourceIamPolicy(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get IAM policy",
			fmt.Sprintf("Error retrieving current IAM policy: %v", err),
		)
		return
	}
	tflog.Debug(ctx, "Retrieved current access bindings", map[string]interface{}{
		"secret_id":      u.secretId,
		"current_policy": p,
	})
	tflog.Debug(ctx, "Applying policy delta", map[string]interface{}{
		"delta": policyDelta,
	})

	if err := u.UpdateResourceIamPolicy(ctx, policyDelta); err != nil {
		if accessbinding.IsStatusWithCode(err, codes.NotFound) {
			tflog.Debug(ctx, "secret not found", map[string]interface{}{
				"secret_id": u.secretId,
			})
			resp.Diagnostics.AddError(
				"secret Not Found",
				fmt.Sprintf("The secret %s was not found, unable to update IAM policy", u.secretId),
			)
			return
		}

		resp.Diagnostics.AddError(
			"Failed to Update IAM Policy",
			fmt.Sprintf("Error updating IAM policy for secret %s: %v\n\n"+
				"Please verify the secret exists and you have sufficient permissions. "+
				"If the issue persists, contact support.",
				u.secretId, err),
		)
		return
	}

	var sleep types.Int64
	req.Plan.GetAttribute(ctx, path.Root("sleep_after"), &sleep)
	if !sleep.IsNull() && !sleep.IsUnknown() {
		time.Sleep(time.Second * time.Duration(sleep.ValueInt64()))
	}

	u.refreshMemberState(ctx, req.Plan, &resp.State, resp.Diagnostics)
}

func (u *IAMMemberUpdater) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()

	u.Initialize(ctx, req.State, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	u.refreshMemberState(ctx, req.State, &resp.State, resp.Diagnostics)
}

func (u *IAMMemberUpdater) Update(_ context.Context, _ resource.UpdateRequest, _ *resource.UpdateResponse) {
}

func (u *IAMMemberUpdater) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()

	u.Initialize(ctx, req.State, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	member := accessbinding.GetResourceIamMemberFromState(ctx, req.State, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	policyDelta := &accessbinding.PolicyDelta{
		Deltas: []*access.AccessBindingDelta{
			{
				Action:        access.AccessBindingAction_REMOVE,
				AccessBinding: member,
			},
		},
	}

	mutexKV.Lock(fmt.Sprintf("yandex_lockbox_secret_iam_member-%s", u.secretId))
	defer mutexKV.Unlock(fmt.Sprintf("yandex_lockbox_secret_iam_member-%s", u.secretId))

	tflog.Debug(ctx, fmt.Sprintf("Retrieving access member for yandex_lockbox_secret_iam_member '%s'", u.secretId))

	p, err := u.GetResourceIamPolicy(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to get IAM policy",
			fmt.Sprintf("Error retrieving current IAM policy: %v", err),
		)
		return
	}
	tflog.Debug(ctx, "Retrieved current access bindings", map[string]interface{}{
		"secret_id":      u.secretId,
		"current_policy": p,
	})
	tflog.Debug(ctx, "Applying policy delta", map[string]interface{}{
		"delta": policyDelta,
	})

	if err = u.UpdateResourceIamPolicy(ctx, policyDelta); err != nil {
		if accessbinding.IsStatusWithCode(err, codes.NotFound) {
			tflog.Debug(ctx, "Resource not found, assuming already deleted")
			return
		}
		resp.Diagnostics.AddError(
			"Failed to update IAM policy",
			fmt.Sprintf("Error deleting IAM member: %v", err),
		)
		return
	}

	u.refreshMemberState(ctx, req.State, &resp.State, resp.Diagnostics)
}

func (u *IAMMemberUpdater) GetResourceIamPolicy(ctx context.Context) (*accessbinding.Policy, error) {
	var bindings []*access.AccessBinding
	pageToken := ""

	for {
		md := new(metadata.MD)
		resp, err := lockboxv1sdk.NewSecretClient(u.providerConfig.SDKv2).ListAccessBindings(ctx, &access.ListAccessBindingsRequest{
			ResourceId: u.secretId,
			PageSize:   defaultPageSize,
			PageToken:  pageToken,
		}, grpc.Header(md))
		if err != nil {
			return nil, err
		}

		if traceHeader := md.Get("x-server-trace-id"); len(traceHeader) > 0 {
			tflog.Debug(ctx, "List yandex_lockbox_secret_iam_member trace header", map[string]interface{}{
				"x-server-trace-id": traceHeader[0],
			})
		}
		if traceHeader := md.Get("x-server-request-id"); len(traceHeader) > 0 {
			tflog.Debug(ctx, "List yandex_lockbox_secret_iam_member request header", map[string]interface{}{
				"x-server-request-id": traceHeader[0],
			})
		}

		bindings = append(bindings, resp.AccessBindings...)

		if resp.NextPageToken == "" {
			break
		}

		pageToken = resp.NextPageToken
	}

	return &accessbinding.Policy{Bindings: bindings}, nil
}

func (u *IAMMemberUpdater) SetResourceIamPolicy(ctx context.Context, policy *accessbinding.Policy) error {
	req := &access.SetAccessBindingsRequest{
		ResourceId:     u.secretId,
		AccessBindings: policy.Bindings,
	}

	md := new(metadata.MD)
	ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()

	op, err := lockboxv1sdk.NewSecretClient(u.providerConfig.SDKv2).SetAccessBindings(ctx, req, grpc.Header(md))
	if err != nil {
		return fmt.Errorf("error setting access bindings of yandex_lockbox_secret_iam_member '%s': %w", u.secretId, err)
	}

	_, err = op.Wait(ctx)
	if err != nil {
		return fmt.Errorf("error setting access bindings of yandex_lockbox_secret_iam_member '%s': %w", u.secretId, err)
	}

	return nil
}

func (u *IAMMemberUpdater) UpdateResourceIamPolicy(ctx context.Context, policy *accessbinding.PolicyDelta) error {
	var (
		bSize  = defaultPageSize
		deltas = policy.Deltas
		dLen   = len(deltas)
	)

	for i := 0; i < accessbinding.CountBatches(dLen, bSize); i++ {
		req := &access.UpdateAccessBindingsRequest{
			ResourceId:          u.secretId,
			AccessBindingDeltas: deltas[i*bSize : min((i+1)*bSize, dLen)],
		}

		op, err := lockboxv1sdk.NewSecretClient(u.providerConfig.SDKv2).UpdateAccessBindings(ctx, req)
		if err != nil {
			if reqID, ok := accessbinding.IsRequestIDPresent(err); ok {
				tflog.Debug(ctx, "Request ID from error response", map[string]interface{}{
					"request_id": reqID,
					"error":      err.Error(),
				})
			}
			return fmt.Errorf("error updating access bindings of yandex_lockbox_secret_iam_member '%s': %w", u.secretId, err)
		}

		_, err = op.Wait(ctx)
		if err != nil {
			return fmt.Errorf("error updating access bindings of yandex_lockbox_secret_iam_member '%s': %w", u.secretId, err)
		}
	}

	return nil
}

func (u *IAMMemberUpdater) refreshMemberState(ctx context.Context, req accessbinding.Extractable, resp accessbinding.Settable, diag diag.Diagnostics) {
	member := accessbinding.GetResourceIamMemberFromState(ctx, req, &diag)
	if diag.HasError() {
		return
	}

	clearState := func() {
		tflog.Debug(ctx, "Clearing state for missing binding", map[string]interface{}{
			"secret_id": u.secretId,
			"member":    accessbinding.CanonicalMember(member),
			"role":      member.RoleId,
		})
		diag.Append(resp.SetAttribute(ctx, path.Root("secret_id"), "")...)
		diag.Append(resp.SetAttribute(ctx, path.Root("role"), "")...)
		diag.Append(resp.SetAttribute(ctx, path.Root("member"), "")...)
		var sleep types.Int64
		req.GetAttribute(ctx, path.Root("sleep_after"), &sleep)
		diag.Append(resp.SetAttribute(ctx, path.Root("sleep_after"), sleep)...)
	}

	p, err := u.GetResourceIamPolicy(ctx)
	if err != nil {
		if accessbinding.IsStatusWithCode(err, codes.NotFound) {
			tflog.Debug(ctx, "Resource not found, removing from state", map[string]interface{}{
				"secret_id": u.secretId,
				"member":    accessbinding.CanonicalMember(member),
				"role":      member.RoleId,
			})
			clearState()
			return
		}
		diag.AddError(
			"Failed to get IAM policy",
			fmt.Sprintf("Error retrieving current IAM policy for secret %s: %v", u.secretId, err),
		)
		return
	}

	tflog.Debug(ctx, "Retrieved current access bindings", map[string]interface{}{
		"secret_id":     u.secretId,
		"binding_count": len(p.Bindings),
	})

	var roleBindings []*access.AccessBinding
	for _, b := range p.Bindings {
		if b.RoleId == member.RoleId {
			roleBindings = append(roleBindings, b)
		}
	}

	if len(roleBindings) == 0 {
		tflog.Debug(ctx, "No bindings found for role", map[string]interface{}{
			"secret_id": u.secretId,
			"role":      member.RoleId,
		})
		clearState()
		return
	}

	memberExists := false
	canonicalMemberValue := accessbinding.CanonicalMember(member)
	for _, b := range roleBindings {
		if accessbinding.CanonicalMember(b) == canonicalMemberValue {
			memberExists = true
			break
		}
	}

	if !memberExists {
		tflog.Debug(ctx, "Member not found in role bindings", map[string]interface{}{
			"secret_id": u.secretId,
			"member":    canonicalMemberValue,
			"role":      member.RoleId,
		})
		clearState()
		return
	}

	diag.Append(resp.SetAttribute(ctx, path.Root("secret_id"), u.secretId)...)
	diag.Append(resp.SetAttribute(ctx, path.Root("role"), member.RoleId)...)
	diag.Append(resp.SetAttribute(ctx, path.Root("member"), canonicalMemberValue)...)
	var sleep types.Int64
	req.GetAttribute(ctx, path.Root("sleep_after"), &sleep)
	diag.Append(resp.SetAttribute(ctx, path.Root("sleep_after"), sleep)...)
}
